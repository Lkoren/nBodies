<!DOCTYPE html>
<html lang="en">
	<head>
		<title>orbit controls test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>

	<body>
		<div id="container"></div>		
		<script src="C:/Liav/webdev/three.js/build/three.min.js"></script>
		<script src="C:/Liav/webdev/three.js/examples/js/controls/OrbitControls.js"></script>	
		<script>

/* to do: 
- link mesh creation to body creation.
- seperate physics logic into new file
- add rk4 integration method
- ability to serialize and save/load state 
- GUI 
- STAR TRAILS
- shader effects
- energy vizulization
- numerical easing
- move to THREE's partical system?
- extend Vector3's syntax to be more natural?
- profile/optimize the code?
	- impliment parts in asm.js?
- astronomical orbit visualizations?
- impliment something from http://suki.ipb.ac.rs/3body/ ??? 
*/
			var container;
			var camera, controls, scene, renderer;	
			var starMesh;		
			init();
			animate();
			function Body() {
				this.mass = 0.1;
				this.pos = new THREE.Vector3(0,0,0);
				this.vel = new THREE.Vector3(0,0,0);
			}
			Body.prototype.accel = function(body_array) { // return the accel vector on a body, produced by all other bodies.
				a = new THREE.Vector3(0,0,0);
				for (var i = 0; i < body_array.length; i++) {					
					if (!(body_array[i] === this)) { //refactor internal to something less ugly. PS -- I miss you "unless"! Love you!
						var r = new THREE.Vector3(0,0,0); 
						r.copy(body_array[i].pos);
						r.sub(this.pos); //get the distance between bodies.
						var r2 = r.dot(r);
						var r3 = r2*Math.sqrt(r2);						
						a.add(r.multiplyScalar(body_array[i].mass/r3)); //toDo: create copy method for body
					}
				}
				return a;
			}
			Body.prototype.ekin = function() {
				return 0.5*this.mass*this.vel.dot(this.vel);
			}
			Body.prototype.epot = function(body_array){
				ep = 0.0;
				for (var i = 0; i < body_array.length; i++) {					
					body = body_array[i]; 					
					if (!(body === this)) {
						var r = new THREE.Vector3(0,0,0); 
						r.copy(body.pos);
						r.sub(this.pos); //get the distance between bodies.
						ep += -1*body.mass*this.mass/Math.sqrt(r.dot(r));
					}
				}
				return ep;
			}
			Body.prototype.to_s = function() {
				console.log("Mass = ", this.mass);
				console.log("Pos = ", this.pos);
				console.log("Vel = ", this.vel);
			}	
			Body.prototype.bodyCalc = function(body) {
				console.log("hello from body calc!")
				console.log("body: ", bodies);
			}		
			/////////////////
			function Nbody() {
				var numBodies = 2;
				this.e0 = 0.0;
				this.dt = 0.001;
				this.dt_end = 10.0;
				this.nSteps = 0;
				this.bodies = new Array(numBodies);
				for (var i =0; i < numBodies; i++) {
					this.bodies[i] = new Body();					
				}				
				this.time = 0;				
				this.bodies[0].pos = new THREE.Vector3(1,0,0);
				this.bodies[1].pos = new THREE.Vector3(0,0,0);
			}
			Nbody.prototype.nextStep = function(params) { //ToDo: have dt, dt_end, and integration method as params	
				console.log("dt = ", this.dt, " nSteps = ", this.nSteps, " time = ", this.time)			;
				this.dt = params.dt || this.dt;
				this.dt_end = params.dt_end || this.dt_end;				
				var t_end = this.dt_end - 0.5*this.dt;
				while (this.time < t_end) {
					this.integrate();
					this.time += this.dt;
					this.nSteps++;
				}
			}
			Nbody.prototype.leapfrog = function() { ////////////////////////////////////LEAPFROG integrator
				var dt = this.dt;
				var bodyArr = this.bodies; //get all the bodies								
				this.bodies.forEach(function(body) {	
					var tempVel = new THREE.Vector3(0,0,0);
					body.vel.add(body.accel(bodyArr).multiplyScalar(0.5*dt));	
					tempVel.copy(body.vel);
					body.pos.add(tempVel.multiplyScalar(dt));
					body.vel.add(body.accel(bodyArr).multiplyScalar(0.5*dt));
				})
			}
			Nbody.prototype.integrate = function() {
				this.leapfrog();
			}
			Nbody.prototype.simple_print = function() {
				str = ["Total bodies: ", 2, "\n", 
						"dt: ", this.dt, "\n", 
						"at time: ", this.time, "after ", this.nSteps, "steps: \n"].join(" ");
				console.log(str);
				this.bodies.forEach(function(body) {
					body.to_s();
				})
				nrg = ["kin energy = ", this.ekin(), "\n",
						"pot energy = ", this.epot(), "\n",
						"total energy = ", this.e_tot(), "\n",
						"(e_init - e_fin)/e_init: ", (this.e0 - this.e_tot())/this.e0].join(" ");
				console.log(nrg);
			}
			Nbody.prototype.ekin = function() {
				ek = 0.0;
				this.bodies.forEach(function(body){
					ek += body.ekin();
				})
				return ek;
			}			
			Nbody.prototype.epot = function() {
				ep = 0.0;
				var bodyArr = this.bodies;
				this.bodies.forEach(function(body) {
					ep += body.epot(bodyArr);
				})
				return ep/2;
			}
			Nbody.prototype.e_init = function() {
				return this.e0 = this.ekin() + this.epot();
			}
			Nbody.prototype.e_tot = function() {
				return (this.ekin() + this.epot());
			}
			var nb = new Nbody(); //for testing purposes;
			nb.bodies[0].pos.x = 0.5;
			nb.bodies[0].pos.y = 0.0;
			nb.bodies[0].pos.z = 0.0;
			nb.bodies[0].vel.x = 0.0;
			nb.bodies[0].vel.y = 0.22360679774997896964; //test3.in setting
			//nb.bodies[0].vel.y = 0.5; //test5.in
			nb.bodies[0].vel.z = 0.0;

			nb.bodies[1].pos.x = -0.5;
			nb.bodies[1].pos.y = 0.0;
			nb.bodies[1].pos.z = 0.0;
			nb.bodies[1].vel.x = 0.0;
			nb.bodies[1].vel.y = -0.22360679774997896964; //test3.in setting
			//nb.bodies[1].vel.y = -0.5; //test5.in
			nb.bodies[1].vel.z = 0.0;

			nb.e0 = nb.e_tot();
			//nb.e_init();
			nb.simple_print();
			//nb.nextStep({});
			nb.simple_print();


			function init() {
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 20;
				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
				scene = new THREE.Scene();
				starGeom = new THREE.TetrahedronGeometry(0.1,0);			
				var starMaterial = new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true});
				starMesh = new THREE.Mesh(starGeom, starMaterial);
				scene.add(starMesh);				
				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );			
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				render();
			}
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				render();
			}
			function render() {		
				starMesh.rotation.x += 0.01;
				starMesh.rotation.y += 0.03;
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
